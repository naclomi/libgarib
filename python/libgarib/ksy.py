import re

from ._version import __version__

def to_upper_camel(string):
    path_components = str(string).split(".")
    final_path = []
    for component in path_components:
        words = re.split(r"[\s_\-]+", component)
        final_path.append("".join(word.capitalize() for word in words))
    return ".".join(final_path)

def seq_by_id(seq, key):
    for elem in seq:
        if elem["id"] == key:
            return elem
    else:
        raise KeyError(key)

def levelKsyToDtd(ksy, ksy_filename):
    indent = "   "
    dtd = ["<!--\n{indent}WARNING!!\n{indent}THIS FILE IS AUTOGENERATED FROM {ksy_filename}\n{indent}DIRECT EDITS TO IT WILL LIKELY BE LOST\n-->\n".format(**locals())]

    cmd_list = []
    for type_name, type_def in ksy["types"].items():
        polymorphic = type_def.get("-semantic", {}).get("polymorphic-wrapper-of", None)
        if polymorphic is None:
            cmd_list.append(to_upper_camel(type_name))

    cmd_list = " |\n{indent}".format(**locals()).join(cmd_list)
    version = __version__

    dtd.append("<!ELEMENT Level ((\n{indent}{cmd_list}\n)*)>".format(**locals()))
    dtd.append("{indent}<!ATTLIST Level name CDATA #REQUIRED>".format(**locals()))
    dtd.append("{indent}<!ATTLIST Level libgarib-version CDATA #FIXED \"{version}\">".format(**locals()))
    dtd.append("")

    cmd_declares = {}
    valid_children = {}
    polymorphic_types = {}

    for type_name, type_def in ksy["types"].items():
        polymorphic = type_def.get("-semantic", {}).get("polymorphic-wrapper-of", None)
        if polymorphic is not None:
            polymorphic_types[type_name] = list(set(seq_by_id(type_def["seq"], polymorphic)["type"]["cases"].values()))

    for type_name, type_def in ksy["types"].items():
        declares = type_def.get("-semantic", {}).get("declares", [])
        if not isinstance(declares, list):
            declares = [declares]
        for decl_type in declares:
            decl_list = cmd_declares.get(decl_type, [])
            decl_list.append(type_name)
            cmd_declares[decl_type] = decl_list
        if len(declares) > 0:
            valid_children[type_name] = []

    for type_name, type_def in ksy["types"].items():
        modifies = type_def.get("-semantic", {}).get("modifies", [])
        if not isinstance(modifies, list):
            modifies = [modifies]

        polymorphic = type_def.get("-semantic", {}).get("polymorphic-wrapper-of", None)
        if polymorphic is not None:
            child_tags = polymorphic_types[type_name]
        else:
            child_tags = [type_name]

        for mod_type in modifies:
            parent_tags = cmd_declares[mod_type]
            for parent_tag in parent_tags:
                for child_tag in child_tags:
                    valid_children[parent_tag].append(child_tag)


    for type_name, type_def in ksy["types"].items():
        polymorphic = type_def.get("-semantic", {}).get("polymorphic-wrapper-of", None)
        if polymorphic is not None:
            continue
        if type_name in valid_children:
            type_list = " | \n{indent}".format(**locals()).join(to_upper_camel(name) for name in valid_children[type_name])
            type_body = "(\n{indent}{type_list}\n)*".format(**locals())
        else:
            type_body = "EMPTY"
        py_type_name = to_upper_camel(type_name)
        dtd.append("<!ELEMENT {py_type_name} {type_body}>".format(**locals()))
        for arg_def in type_def["seq"]:
            arg_name = arg_def["id"]
            dtd.append("{indent}<!ATTLIST {py_type_name} {arg_name} CDATA #REQUIRED>".format(**locals()))
        dtd.append("")

    return "\n".join(dtd)
